### 其他知识

#### 埋点

**1、概念**

又称为事件追踪（Event Tracking），指的是针对特定用户行为或事件进行捕获，处理和发送的相关技术及其实施过程。可以收集一些用户的行为数据。

功能方面：埋点是用来收集用户行为数据。比如想要了解一个用户在APP里面点击了哪些按钮，看了哪些页面，做了哪些事情等，就可以通过埋点来实现。

实现方式方面：

- 前端代码置入埋点，通过植入一段代码到某个页面mounted或按钮click的时候，去监听用户行为并进行收集上报，使用神策埋点等，将自动收集到的用户数据上报到数据分析平台，再在平台上去分析存储采集数据，对用户行为进行分析。
- 后端日志埋点
- 移动端SDK埋点

通常使用JSONP的方法去进行埋点，利用图片自带的跨域功能：

1、.gif图片自带跨域功能，能解决跨域问题

2、图片比较轻量级

3、使用gif跨域，发送请求时不需要响应回复，因为埋点业务需求，像是看个课程，只需要捕捉用户点击观看课程的行为即可，无需关心该请求是否成功







#### 自定义表格列宽度

需求：el-table的表格设置了**resizable**（默认是true），表格可自定义列的宽度，用户希望在刷新之后，保留自己自定义的宽度。

```js
<el-table  ref="xeTable"  @header-dragend="handleHeaderDragEnd">
     <el-table-column  ref="columnRefs" 
     :width="(columnWidthData.find(item => item.props === column.prop) || {}).width || column.width">

<script>
   data： columnWidthData: []  //用于保存缓存中的数据
   mounted() {
        //挂载时，设置本地缓存信息
        if( localStorage.getItem('column-widths') === null){
            //缓存中没有'column-widths'这个key值的缓存，就缓存一遍
            const tableRefs = this.$refs.xeTable.columns; //针对表格的列，获取的是表格
            for (let i = 0; i < tableRefs.length; i++) {
                const column = tableRefs[i];
                const props = column.property;
                const width = `${column.width}px`;
                this.columnWidthData.push({ props, width });
            }
            localStorage.setItem('column-widths', JSON.stringify(this.columnWidthData));
        }
        //有缓存则拿到缓存内容
        this.columnWidthData = JSON.parse(localStorage.getItem('column-widths'))
        const columnRefs = this.$refs.columnRefs;   //针对具体的vc实例的列，因为要设置style
        for (let i = 0; i < columnRefs.length; i++) {
            const prop = columnRefs[i].columnConfig.property;
            const widthInfo = this.columnWidthData.find(item => item.props === prop);
            const width = widthInfo ? widthInfo.width : columnRefs[i].width;
            columnRefs[i].$el.style.width = width;
        }
    },
    methods: {
        handleHeaderDragEnd(newWidth, oldWidth, column, event) {
            //自带的，宽度变化时触发，更新缓存
            this.columnWidthData = JSON.parse(localStorage.getItem('column-widths'))
            const index = this.columnWidthData.findIndex((item) => item.props === column.property);
            if (index !== -1) {
                this.columnWidthData[index].width = `${newWidth}px`;
                localStorage.setItem('column-widths', JSON.stringify(this.columnWidthData));
            }
        },
    }
```

知识点：表格的数据渲染也可以使用动态渲染，将表格的列属性存成一个对象数组，el-table-column中的各个属性采用动态渲染即可。其中每一列的数据处理，可以使用render函数，与formatter作用一样，需要return。



#### 表格拖拽排序

需求：用户希望表格行可以进行拖拽排序，且排完之后，可以将数据保存至数据库中。

方法：使用第三方轻量级库sortablejs，在一个包含多个子元素的容器上应用 `sortable` 类，然后利用nextTick异步方法，在下次 DOM 更新循环结束之后执行延迟排序的回调方法，在表格数据变化后立即使用新的 DOM 来更新 UI。

实现跨页面拖拽排序：

1、将页面大小放大，拖拽结束之后再自行自行切换页面大小

2、给列表每一行增加index权重，用户可填写，填写完之后，权重越大，越往上。

3、给每一行增加两个上下图标，上图标可将改行数据与上一页的最后一行数据交换位置，下图标可将该行数据与下一页数据的第一个数据交换位置

```js
import Sortable from 'sortablejs'
<el-table-column min-width="50" align="center" >
   <template #default>
       <el-icon :size="20" class="drag_icon"><Rank /></el-icon>
   </template>
</el-table-column>

const getCommendListQuest = async (type) => {  //获取表格数据
    try {
        loading.value = true;
        const params = {......};
        const recommendResult = await fetchRecommendList(params);
        templateData.value = recommendResult.data.list || [];   //表格数据templateData
        total.value = recommendResult.data.total || 0; 
        //在这获取到是拖拽排序前的数据，不会在拖拽后改变
        orders = templateData.value.map(v => v.order);
        nextTick(() => {   
            setSort()    //在这里调用拖拽排序方法
        })
    } .....
 };

const sortable = ref();
const setSort = () => {
    //获取第一个tr作为拖拽排序容器，具体类名可以后台查看
    const el = document.querySelectorAll('.el-scrollbar__view > table > tbody')[0]
    sortable.value = Sortable.create(el, {  //创建Sortable实例
       handle: '.drag_icon', // 拖拽图标的选择器，只有拖动图标才能进行拖拽排序
       ghostClass: 'sortable-ghost',
       setData: function(dataTransfer) {         //兼容火狐浏览器
           dataTransfer.setData('Text', '') //拖拽时需要传递的数据格式。
       },
       onEnd: event => {  //在列表中旧的index、拖拽到的新的index，向下拖往上挤，向上拖往下挤
       //使用splic方法将拖拽的元素从原位置删除，并插入到新位置。
       templateData.value.splice(event.newIndex, 0, templateData.value.splice(event.oldIndex, 1)[0])
	//这里的templateData为排序之后的数据，在这之后进行后端交互
       const params = {
            id: ids,
            order: orders
        })
    }
```



#### web worker

简介：js最初设计是运行在浏览器中的，为了防止多个线程同时操作DOM，带来渲染冲突问题，所以js执行器被设计成**单线程**。js线程往往会被长时间阻塞，甚至造成页面卡顿，影响用户体验。为了解决单线程带来的这一弊端，Web Worker 应运而生。将主线程中耗时的同步操作，交给子线程(一个JS文件)，子线程是浏览器开的，完全受主线程控制

`Web Worker` 是 HTML5 标准的一部分，这一规范定义了一套 API，允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js 操作多线程的能力。

**1、使用限制**

- **同源限制**

  分配给 worker 线程的脚本，必须和主线程脚本同源。

- **DOM限制**

  Worker 工作在子线程，和主线程不太一样。所以并无法操作 DOM \ BOM 等 API。（纯数据处理）

- **全局对象限制**

  webworker运行在另一个全局上下文中，Worker 全局对象不是 `window`,所以一些 `window` 上的全局属性和方法也无法访问。（但可以访问 `Navigator` 和 `Location`接口）

- **脚本限制**

  可以在 Worker 中使用 `XMLHttpRequest` 来发送异步请求。

- **通信限制**

  通过postMessage方式进行通信，此通信方式为浅拷贝关系，传值而不是传址，主线程改变值，子线程无法监听到

  

**2、API**

主线程

```js
//创建worker实例
//第一个参数：子线程的文件绝对位置，第二个参数：子线程的名字
const worker = new Worker('worker.js',{name: 'myWorker'})
//在主线程中，给子线程发送数据
worker.postMessage(data);
//在主线程中，接收子下线程返回的数据
worker.onmessage = (data) => {
    console.log('来自子线程的数据',data)
}
//在主线程中，监听子线程的错误
worker.onerror = () => {}
//主线程关闭子线程
worker.terminate();
```

子线程( worker.js )

```js
//self是子线程本身，即子线程的全局对象，相当于window，可以不写  self.xxx   xxx   this.xxx  三种写法
//监听主线程发送的数据
self.onmessage = (event) => {
    console.log('来自主线程的数据',event.data)
}
self.addEventListener('message',(event) => {  //与onmessage监听作用一样
    self.postMessage('you said+',event.data);
},false)
//向主线程发送数据
self.postMessage(data)
//监听自己的错误
self.onerror = (error) => {}

//关闭自己，一般向主线程发送数据之后，将关闭自己
self.onClose()

//在子线程中引入其他脚本
importScripts('script1.js', 'script2.js');
```



**3、Vite+vue3+TS使用web worker**

```js
//1、新建worker文件夹，新建index.ts文件
self.onmessage = (e) => {
  console.log('主线程发送过来的数据', e.data)
  const { data } = e
  setTimeout(() => {
    data.name = 'wq'
    self.postMessage(data)
  }, 5000);
}

//2、在项目中引入worker
import Worker from '@/worker/index?worker'
// vite项目如何引用worker 参考https://cn.vitejs.dev/guide/features.html
 
const workderData = ref({
  name: '王琪',
  age: 26
})
const sendData = () => {
  const worker = new Worker()
  worker.postMessage(JSON.parse(JSON.stringify(workderData.value)))
  worker.onmessage = e => {
    console.log('线程完成', e.data)
    workderData.value = e.data
  }
}
```







#### 表格内容换行不居中

场景：表格，当单元格内容过长时会进行换行，需要在换行的同时，保持文本左对齐，换行的文本不能居中显示。

```js
//表格该列使用插槽，插入重新设置样式的div文本
<el-table-column prop="content" label="模板内容" min-width="330" align="center" >
     <template #default="{ row }">
        <div style="display: inline-block; text-align: left; white-space: pre-line">
        	{{ row.content }}       
        </div>  
     </template>
</el-table-column>
```



#### 新建表单重复出现验证

```js
const resetForm = (formEl: FormInstance | undefined) => {
    if (!formEl) return
    formEl.resetFields();
}
const newRecommendFormRef = ref<FormInstance>(); //获取表单ref
const handleAdd = () => {
    isEdit.value = false;
    drawerVisible.value = true;
    resetForm(newRecommendFormRef.value);  //在“打开”表单时重置表单
};
```



#### 渲染大量数据至表格

- **分页加载**

  ​		将数据分成较小的分页，每次只渲染当前分页大小的数据，点击下一页的时候再渲染其他数据，或者滚动到底部时再加载数据，这是在开发中常用的方法。

  ```js
  //在请求的时候，添加页面大小及页码两个参数即可，当变化页码时，再重新发一个新的请求，改变页码参数
  ```

- **虚拟滚动技术**(virtual scrolling)

  ​		只渲染可见区域内的数据，而不是全部渲染。通过只渲染当前滚动位置附近的数据，可以减少DOM元素的数量，可以使用现有的虚拟滚动库（React Virtualized、Vue Virtual Scroll等）。优化大量数据列表或表格渲染的技术

- **懒加载**(lazy loading)

  ​		它主要应用于图片、视频、音频等资源的加载。当页面滚动到可见区域时，才会触发数据的加载和渲染。懒加载的目的是减少初始加载的数据量，提高页面的加载速度，并节省带宽和资源。

- **web** **worker** 

  ​		将数据处理的任务放在Web Worker中进行，以避免阻塞主线程。将需要处理的数据传递给Worker线程，然后在Worker线程中进行处理，处理完成后再将结果传回主线程进行渲染。



#### 强缓存问题

问题描述：当前有一个系统，该系统是不断在更新迭代的，每次新功能全网之后，用户在不知道的情况下，就会出现白屏、加载不出内容的情况，查看错误都是404报错，就是缓存的问题，需要用户在清除浏览器强缓存之后再重新登录即可，但这样下去会比较麻烦，每次都需要清除缓存之后再使用系统。

办法：在打包静态资源的时候，不使用自动引入，而是在html中引入一个module-loader.js文件，通过这个文件去动态插入link静态资源。

在运行npm run build时，dist文件夹下的html文件中会打包生成很多link标签，每一个link标签都是css、js代码打包之后的

```js
<link href="/renewal_manage_system/css/AppDetailComp.b84a2add.css" rel="prefetch">
<link href="/renewal_manage_system/css/AppList.352e0dac.css" rel="prefetch">
<link href="/renewal_manage_system/css/HomePage.3c9e18d1.css" rel="prefetch">
<link href="/renewal_manage_system/css/SystemSetting.c9e3529a.css" rel="prefetch">
<link href="/renewal_manage_system/js/404Page.ec4b85fb.js" rel="prefetch">
<link href="/renewal_manage_system/js/AppDetailComp.892bf64f.js" rel="prefetch">
//其中.css、.js前的编码是哈希值，当文件内容改变时，哈希值也会改变，从而使浏览器重新请求该文件，以获取最新的内容。
//浏览器在加载静态资源时，会将这些资源缓存到本地。当用户再次访问相同的页面时，浏览器会从缓存中获取这些资源，从而加快页面加载速度。问题就是，当代码重新打包更新时，用户浏览器缓存的是旧版本的代码，导致用户无法获取新版本的代码，
```

浏览器缓存的是打包后的html页面以及静态资源，当用户访问同一个 URL 的时候，浏览器会先检查本地是否有缓存版本，如果有缓存版本，则直接从本地缓存中获取资源，而不会向服务器发送请求。缓存的版本与服务器上的版本不一致，就可能会导致页面显示错误或无法正常运行。

当打包的静态资源已经添加了哈希值，用户还是无法获取到最新版本的代码，是因为浏览器缓存的是html页面，并不会检测到哈希值的变化，所以最后还是会使用同一个url下的html页面。



已经处理过的方法：

前端和后端都使用no-cache策略，但是会遇到浏览器的兼容性问题，在有些浏览器上是还是在使用缓存，并不会使用新文件。



步骤：

1、在public文件夹下新建一个文件module-loader.js

```js
(function() {
    const url = new URL(location.href);
    const app_id = url.searchParams.get('app_id') || localStorage.getItem('appid');

    moduleInit();
	//通过请求去注入打包后的文件
    function moduleInit() {
        $ajax({
            url: `/scrm_toolbar/modules.js?app_id=${app_id}&stamp=${new Date().getTime()}`,
            success({ responseText }) {
                try {
                    getModules(JSON.parse(responseText));
                } catch (error) {
                    handleError(error);
                }
            },
            error(error) {
                handleError(error);
            }
        });
    }
	//匹配文件，动态注入标签
    function getModules(files) {
        files.forEach((file) => {
            if (/\.js$/.test(file)) {
                let script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = `${file}`;
                document.body.appendChild(script);
            } else if (/\.css$/.test(file)) {
                let link = document.createElement('link');
                link.href = `${file}`;
                link.rel = 'stylesheet';
                document.head.appendChild(link);
            }
        });
    }

    function handleError(error) {
        document.body.innerHTML = `<div id="app" style="text-align: center;padding-top: 100px;">页面资源加载失败，请刷新重试或联系服务管家~</div>`;

        $ajax({
            url: 'https://log.xiaoe-tools.com/skynet',
            method: 'post',
            data: {
                appID: app_id,
                details: {
                    message: 'WeworkToolbar assets response fail',
                    res: error
                },
                level: 'ERROR',
                network: navigator.connection.effectiveType,
                projectName: 'WeworkToolbar',
                time: new Date().getTime(),
                type: 'ASSETS_ERROR',
                ua: navigator.userAgent,
                url: location.href
            }
        });
    }

    //封装ajax请求
    function $ajax(params) {
        const xhr = new XMLHttpRequest();
        const method = params.method ? params.method.toLowerCase() : 'get';
        const data = params.data ? params.data : {};
        let url = params.url;
        xhr.open(method, url, true);
        if (method === 'post') {
            let str = '';
            if (typeof data === 'object') {
                str = JSON.stringify(data);
            }
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-rulencoded');
            xhr.send(str);
        } else {
            xhr.setRequestHeader('If-Modified-Since', 0);
            xhr.setRequestHeader('If-None-Match', 0);
            xhr.send();
        }

        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                if (xhr.status == 200) {
                    params.success && params.success(xhr);
                } else {
                    params.error && params.error(xhr);
                }
            }
        };
    }
})();
```

2、在public文件夹中的index.html中：

```js
<head>
    //http-equiv指定该meta标签的头部名称，该 meta 标签模拟了 HTTP 头部中的 Cache-Control 字段
    //content 属性用于指定该 HTTP 头部字段的值,max-age=0即该 Web 页面的缓存过期时间为 0，即不缓存
    //must-revalidate指示浏览器必须验证缓存的有效性，而不能直接使用缓存的数据。这样可以确保用户总是看到最新的数据，而不会被过期的缓存数据所误导
    //这个不是这次使用的方法需要的代码，是之前尝试过的方法。
    <meta http-equiv="Cache-Control" content="max-age=0,must-revalidate" />
</head>

<body>
    <noscript>
        <strong>We're sorry but Current Web Page doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>

    <div id="app"></div>
	//添加module-loader.js模块，主要是添加这一行代码
    <script src="./module-loader.js"></script>
</body>
```

3、在vue.config.js文件中

​		在 `configureWebpack` 中添加一个 `plugins` 数组，然后将 `HtmlWebpackPlugin` 和 `AssetModulePlugin` 实例添加到数组中。`HtmlWebpackPlugin` 可以生成 HTML 文件，并将打包后的 JS、CSS 文件自动注入到 HTML 中。`AssetModulePlugin` 可以在 webpack 构建完成后，自动生成 HTML 文件和收集打包后的 JS、CSS 文件的 URL。，并将它们的 URL 写入到一个 JSON 文件中。

```js
//fs操作文件系统，
const fs = require('fs');
//要确保HtmlWebpackPlugin插件已经存在，不存在安装npm install --save-dev html-webpack-plugin
const HtmlWebpackPlugin = require('html-webpack-plugin');

//在 webpack 构建完成后，收集打包后的 JS、CSS 文件，并将它们的 URL 写入到一个 JSON 文件中
class AssetModulePlugin {
    apply(compiler) {
         //webpack 的compiler.hooks.afterEmit 钩子，该钩子会在 webpack 构建完成后被调用。
        compiler.hooks.afterEmit.tap('AssetModulePlugin', (compilation) => {
            //用于收集打包后的 JS、CSS 文件的 URL
            let files = [];  

            const initialChunks = compilation.chunks.filter((chunk) => {
                if ('canBeInitial' in chunk) {
                    return chunk.canBeInitial();
                } else {
                    return chunk.isInitial();
                }
            });
	//判断它的后缀名是否是 .js 或 .css，如果是，则将它的 URL 存入 files 数组中
            initialChunks.forEach((chunk) => {
                chunk.files.forEach((file) => {
                    if (/\.(js|css)$/.test(file)) {
    //这里与打包后生成的文件地址有关，URL就是下面配置中的 publicPath
                        files.push(`${URL}${file}`);
                    } else {
                        throw `AssetModulePlugin ${file} 资源类型异常`;
                    }
                });
            });

            fs.writeFileSync('./dist/modules.js', JSON.stringify(files));
        });
    }
}

//由于区分生产环境和开发环境，所以需要判断当前环境之后，再去决定应该是走静态渲染，还是动态渲染
//下面的plugins在实际代码中不写，写这个
const plugins = [
    new HtmlWebpackPlugin({
        template: isDev ? './public/index-dev.html' : './public/index.html',
        inject: isDev,
    }),
];
!isDev && plugins.push(new AssetModulePlugin());

module.exports = {
    publicPath: isDev ? '/' : URL,
    configureWebpack: {
        plugins: [
            new HtmlWebpackPlugin({
                //这里的处理比较复杂，如果是在开发环境中，走的是public/index-dev.html，但是在开发环境中是不会有打包生成的modules.js文件供项目使用的，就会报错，因为没办法加载出静态资源。
                //在生成的 HTML 文件中，JS、CSS 文件的 URL 会自动插入到指定的位置
                template: isDev ? './public/index-dev.html' : './public/index.html',
                //在开发模式下，我们将 inject 设为 true，在生产模式下，我们将 inject 设为 false。
                inject: isDev,
            }),
            new AssetModulePlugin(),
        ],
  	}
}
```

4、验证是否打包成功

- 运行 `npm run build` 命令，进行打包。
- 打包完成后，在 `dist` 目录下查看生成的 `modules.js` 文件，确保其中包含了所有的 JS、CSS 文件的 URL。
- 打开生成的 HTML 文件，查看页面是否正确渲染，并且所有的 JS、CSS 文件是否被正确引入。可以使用浏览器的开发者工具（F12）查看网络请求，确认所有的 JS、CSS 文件都被正确加载。





#### 标签式输入框

场景要求：当用户输入时，按下enter或者失去焦点时，生成tag标签

```js
<!-- 标签式输入框 -->
      <el-scrollbar        //滚动条是因为固定高度，超出内容滚动，实际上是个div
		height="50px" 
		class="edit_tab_input" 
		>
        <el-tag
          v-for="(tag, index) in options"
          :key="index"
          closable     //标签可关闭
          @close="removeTag(inde,item)"   
          style="margin: 0 5px 5px 0;"
        >{{ tag }}</el-tag>
        <input
          v-model="inputValue"
          size="small" 
          @keyup.enter="addTag(item)" 
          @blur="addTag(item)"
          />
      </el-scrollbar>

const inputValue = ref('')   //输入框输入的内容
const addTag = (item) => {   //添加tag标签
  if(inputValue.value.trim() !== ''){
    options.push(inputValue.value.trim());   //往标签数组中添加输入的元素，就可以渲染出来
    inputValue.value = ''  //输入框内容置为空
  }
}
const removeTag = (index,item) => {   //关闭标签的时候，需要将选项内容-1
  item.collectValue.splice(index,1)
}


.edit_tab_input {   
          display: flex;    //flex布局，为了标签和输入框在一行显示
          flex-wrap: wrap;
          padding: 5px;
          width: 100%;
          border: 1.5px solid #dcdfe6;
          border-radius: 5px;
    
          input {
            display: inline-block;   //输入框的样式，做到透明，只含有聚焦鼠标
            width: 35px;
            margin-top: -8px;
            border: 0px solid #c0c4cc;
            outline: none; /* 取消聚焦时的外部边框 */
            box-shadow: none;
            user-select: none;
          }
    
          input:focus {
            border:none;
          }
        }
        .edit_tab_input:hover {   //模拟输入框样式
          border-color: #409eff;
          cursor: text;
        }
```



#### 点击复制文本

```js
  const handleCopy = (text) => {
     //text是想要复制的文本
    navigator.clipboard.writeText(text).then(() => {
      ElMessage.success('复制成功')
    }).catch((error) => {
      console.error('复制失败', error)
      ElMessage.error('复制失败')
    })
  }
```



#### 滚动条样式

```js
    overflow-y: scroll;
    &::-webkit-scrollbar {
        width: 6px; /* 设置滚动条的宽度 */
        position: absolute;
        left: 0;
    }

    /* 设置滚动条的轨道样式 */
    &::-webkit-scrollbar-track {
        background-color: transparent; /* 滚动条轨道背景色 */
    }

    /* 设置滚动条滑块的样式 */
    &::-webkit-scrollbar-thumb {
        width: 4px;
        border-radius: 5px; /* 滑块圆角 */
        background-color: #e5e5e5; /* 滑块颜色 */
    }
```

注意：当样式难修改的时候，考虑使用::deep(.类名)来尝试修改子组件的样式，不用担心样式封装的问题



#### 自定义实现单选按钮样式

```js
<div class="tabs-change">
   <div 
      v-for="item in collectRadio" 
      :key="item.key"  
      @click="radioChange(item.label)" 
      class="tabs-temp" 
      :class="{ 'selected': item.label === activeCollectRadio }"
   >
      <span>{{ item.label }}</span>
    </div>
</div>

//collectRadio是单选按钮的选项
const activeTempRadio = ref('全部') //默认选中
const radioChange = (label: any) => {
    //当重复点击时，取消选中
    if (activeTempRadio.value === label )  return 
    activeTempRadio.value = label;
}

//样式
.tabs-change {
    display: flex;   //flex布局，横向排列
    flex-direction: row;
    .tabs-temp {    //未选中时按钮样式
        height: 32px;
        padding: 2px 16px;
        margin-right: 8px;
        border-radius: 4px;
        background: #f4f6fa;
        font-size: 14px;
        line-height: 32px;
        cursor: pointer;
    }
    .tabs-temp.selected {     //选中时的样式
        background: #e9f2ff;
        color: #1472FF;
    }
}
```



#### 实现三角形

```js
/\
.triangle {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
}
\/
    .triangle {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-top: 100px solid red;
}
尖尖向左
.triangle {
    width: 0;
    height: 0;
    border-top: 50px solid transparent;
    border-right: 100px solid red;
    border-bottom: 50px solid transparent;
}
尖尖向右
.triangle {
    width: 0;
    height: 0;
    border-top: 50px solid transparent;
    border-left: 100px solid red;
    border-bottom: 50px solid transparent;
}
直角三角形
.triangle {
    width: 0;
    height: 0;
    border-top: 100px solid red;
    border-right: 100px solid transparent;
}
```



#### 去掉空格

```js
//trim()只能去掉字符串最后的空格
//使用正则表达式
str.replace(/\s+/g, '');//将所有的空格匹配出来并且以空字符串替换
```



#### 打字效果的实现

```js
//DOM元素
<el-skeleton :rows="3" animated v-if="isCreating"/>
<el-input    //打字效果一定要是一个text的input框
   v-else
   ref="generateResultInput"
   v-model="generateResult"
   class="generate-result-input"
   autosize
   type="textarea"
   resize="none"
/>

const generateResultInput = ref<HTMLElement | null>(null);

//如果只在当前页面数据的话，不需要那么麻烦，只需要动态给某一个变量增加字符串就行
const generateResult = computed({      //动态计算文本内容，动态获取和添加文本
    get: () => commonStore.activeTypeText || '',
    set: (value) => commonStore.setActiveTypeText(value)
});
       
const content = typeText as string;   //打字的文本
await nextTick();
let scrollEl: HTMLElement | null = null;
isTyping.value = true;  //设置打字状态为true，开始打字

let i = 0;
const timer = setInterval(async () => {
    //不断往文本中增加内容
    commonStore.setActiveTypeText(commonStore.activeTypeText + content.charAt(i));
    
    if (!scrollEl) {
        //获取打字效果的输入框
    	scrollEl = document.querySelector('.generate-result-input') as HTMLElement;
    }
    await nextTick();
    if (scrollEl) {
        scrollEl.scrollTop = scrollEl.scrollHeight;
    }
    i++;
    if (i > content.length) {
        isTyping.value = false;
    	clearInterval(timer);
    }
}, 50);//50:打字速度


//注意设置输入框在输入文本时的样式，这会影响打字效果的呈现
.generate-result-input {
    display: block;
    box-sizing: border-box;
    width: 100%;
    font-size: 16px;
    line-height: 20px;
    color: #333;
    font-family: 'PingFang SC';
    background-color: #edebeb;
    :deep(.el-textarea__inner) {
        //打字的效果
        box-shadow: 0 0 0 0px;
        padding:0px;
        background-color: #edebeb;
    }
}
```







#### 新手引导

使用插件**driver.js** 实现新手引导

```js
//1、下载插件     npm install driver.js

//2、在展示新手引导的页面中引入插件
import { driver } from "driver.js";
import "driver.js/dist/driver.css";

//3、定义新手引导的步骤
const STEPS = [
    {
        element: '.edit',         //使用元素选择器选中新手引导的元素
        popover: {
            title: '创作要求',      //气泡的标题
            description:          //气泡的描述，可解析html语言
                '<div>根据使用文案的场景，填入创作要求。</div><div>点击[智能生成]按钮，AI将按照指示进行创作。</div><div style="position:absolute;top:120px;color:#7d7d7d;background-color:#ffffff;width:40px;">1/2</div>',
            position: 'right'     //气泡展示在元素的什么方向
        }
    },
    {
        element: '.generate-result',
        popover: {
            title: '创作结果',
            description:
                '创作内容生成后，可以在编辑栏进行修改，直接复制或保存使用。赶紧试试吧！<div style="position:absolute;top:120px;color:#7d7d7d;background-color:#ffffff;width:40px;">2/2</div>',
            position: 'left'
        }
    }
];

//4、创建driver类实例
const drivers = driver({
  showProgress: true,    是否展示 步骤
  allowClose: false,     是否可以关闭
  doneBtnText: '完成',    最后一步的文本
  prevBtnText: '上一步',  
  nextBtnText: '下一步', 
  steps: STEPS           步骤的内容，使用定义的
})

//5、定义气泡样式，可以在检查中找到该元素的类名，设置样式
div.driver-popover {
    max-width: 332px;
    padding: 16px 20px;
    .driver-popover-title {
        font-weight: 600;
    }
    .driver-popover-description {
        margin-top: 16px!important;
    }
    .driver-popover-footer {
        .driver-popover-navigation-btns {
            .driver-popover-prev-btn {
                width: 70px;
                text-align: center;
            }
            .driver-popover-next-btn {
                width: 70px;
                text-align: center;
                color: #ffffff;
                background-color: #1472FF;
                border: 1px solid #1472FF;
                text-shadow:none
            }
        }
        .driver-popover-btn-disabled {
            opacity: 0;
        }
    }
}
```





#### flex布局的卡片中最后一行

一个容器中有多个卡片，为flex布局，卡片具有最大最小宽度和固定高度，当页面大小变化时，除了最后一行之外，其余行的卡片能够更具屏幕大小自适应宽度，但是最后一行展示的是最大宽度，因为flex：1会最大利用剩余空间。

解决办法：

增加足够多的卡片，并将增加的卡片设置样式为透明，其余卡片样式不变，这样既可



#### 自动滚动到某个位置

场景：注意一定要在dom内容更新之后（使用$nextTick) 才去调用scrollIntoView，否则不起作用

- **window.scrollTo(x,y)**

  ```js
  //滚动到坐标（0,500）位置
  window.scrollTo(0, 500);
  
  //滚动到页面某个特定元素
  window.onload = function() {
     // 滚动到具有 id 为 "scrollToSection" 的元素
     var targetElement = document.getElementById('scrollToSection');
     window.scrollTo({
         top: targetElement.offsetTop,
         behavior: 'smooth' // 启用平滑滚动效果
     });
  };
  
  //1、是立即生效的，滚动效果需要使用css设置，scroll-behavior: smooth;
  //2、坐标系统相对于文档页面坐标
  //3、滚动的是整个窗口，而不是特定元素，特定元素使用scrollIntoView()
  ```

- **scrollIntoView（）**

  ```js
  //将某个元素滚动到包含它的父元素的可视区域，或者整个窗口的可视区域
  //元素需要在可滚动的容器内
  
  // 将 整个窗口 滚动到 具有 id 为 "targetElement" 的元素
  document.getElementById('targetElement').scrollIntoView({
    behavior: 'smooth'
  });
  
  // 将 具有 id 为 "targetElement" 的元素 滚动到可见区域
  document.getElementById('targetElement').scrollIntoView({
    behavior: 'smooth', // 滚动行为，auto、smooth（平滑）、instant
    block: 'start', // 垂直方向的对齐方式，start、center、end
    inline: 'start', //水平方向的对齐方式，start、center、end
  });
  ```

  







#### 组件库深度修改样式

当我们在项目中需要给element组件加上一些自定义样式的时候，往往是不生效的。

这是因为**Vue**项目中使用第三方框架的时候，Vue中有**scoped**，声明了样式是在组件范围内生效的，避免了不同组件的样式污染。

- **在类名前加上  /deep/**    （例如el-input__inner)

  ```js
  /deep/ .el-input__inner{
      border-radius: 30px; 
  }
  ```

- **使用深作用选择器    >>>**   只能在原生css中，不能在scss、less等中使用

  ```js
  .my >>> .el-input__inner{
      border-radius: 30px;/* 这些起作用 */
      border: 1px solid #eceef2;
      outline: 0;
  }
  ```

- **在类名前加上  ::v-deep**

  ```js
  ::v-deep .el-dialog__footer{
      background: #000;
  }
  ```

- **使用** **：deep（）**

  ```js
  :deep(.el-textarea__inner) { 
        border: none;
    }
  ```

  



#### 输入字数不计算空格

场景：输入框计数时，不希望计入空格

解决 办法：不使用自带的计数器，而是重新写字数的样式加在后面



#### 历史记录保存问题



#### 中文解码

```js
const content = '%E4%B8%AD%E6%96%87';
var decodeContent = decodeURIComponent(content);
console.log(decodeContent);    //中文
```



#### 数字三位打点

```js
//方法一：正则表达式
const str = '10000000000';
const r = str.replace(/\B(?=(\d{3})+$)/g,',');
console.log(r);   //10,000,000,000

//方法二：自带API
const num = 10000000000;
const r = num.toLocaleString('en-US');
console.log(r);
```



#### 文字背景色

```js
width: 100%;
text-align: center; /* 文字水平居中 */
font-size: 40px;
background: linear-gradient(to bottom, #f89c84, #eee6df); /* 设置渐变背景 */
-webkit-background-clip: text; /* 使背景仅在文字区域可见，适用于WebKit浏览器 */
color: transparent; /* 使文字透明 */
display: inline-block; /* 使渐变背景应用到文字 */
```

