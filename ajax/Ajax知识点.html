<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ajax学习笔记</title>
</head>

<body>
    <!-- 客户端与服务器
        1、服务器：上网过程中，负责存放和对外提供资源的电脑

        2、URL：UniformResourceLocator，中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置
            (1) 组成部分
                    服务器与客户端之间的通信协议
                    存有该资源的服务器名称
                    资源在服务器上的具体存放位置
                    http （通信协议）://www.cnblogs.com（服务器名称）/liulongbinblogs/p/11649393.html（具体位置）

        3、网页请求数据
            (1) 如果要在网页中请求服务器上的数据资源，则需要用到 XMLHttpRequest 对象
            (2) XMLHttpRequest（简称xhr），是浏览器提供的js成员，通过它，可以请求服务器上的数据资源，类似Dom对象
            (3) 最简单的用法 var xhrObj = new XMLHttpRequest()
        
        4、资源请求方式
            客户端请求服务器时，请求方式有多种，最常用的两种请求方式就是 get 和 post 请求
            (1) get 请求通常用于获取服务端资源（向服务器要资源）
                    例如：根据URL地址，从服务器获取HTML文件、图片文件、数据资源等
            (1) post 请求用于向服务器提交数据
                    例如：登录时向服务器提交的登录信息等各种数据提交操作-->




    <!--Ajax（阿甲课丝）
        1、含义
            Ajax的全称是Asynchronous JavaScript And XML （异步JavaScript和XML）
            就是在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式，就是Ajax
            最大的特点：无刷新获取数据

        2、典型应用场景
            (1) 用户名检测：注册用户时，通过Ajax方式，动态检测用户名是否被占用
            (2) 搜索提示：在输入搜索关键字时，通过Ajax方式，动态加载搜索提示列表
            (3) 数据分页显示：当点击页码值的时候，通过Ajax方式，根据页码值动态刷新表格的数据
            (3) 数据的增删改查：数据的添加、查询等操作，都需要通过Ajax方式，实现数据的交互
            (5) 鼠标放上去，出现二级标题菜单的效果
        
        3、XML
            XML被设计用来传输和存储数据，XML和HTML类似，不同的是HTML中都是预定义标签，而XML全都是自动以标签，用来表示一些数据。
            比如有一个学生数据：  name = "sun"; age = 18; sex = "男"
            用XML表示：<student>
                            <name> sun </name>
                            <age>18</age>
                            <sex>男</sex>
                       </student>
            用JSON表示：{"name":"sun","age":18,"sex":"男"}     目前都是使用的JSON
        

        4、Ajax的优缺点
            优点：
                (1) 可以无需刷新页面而与服务器端进行通信
                (2) 允许你根据用户事件更新部分页面
            缺点：
                (1) 没有浏览历史，不能回退
                (2) 存在跨域问题（同源）
                (3) SEO不友好-->




    <!--HTTP
        1、含义
            超文本传输协议，协议详细规定了浏览器和万维网服务器之前相互通信的规则。
            浏览器给服务器发送的是请求，内容称为请求报文-->





    <!-- 请求的环境配置
        (1)在该文件的根目录下右键选择 “终端打开” 启动端口服务 “node postAndget.js" 
        (2) 当接口文件中的内容更新时，需要重新打开-->


    <!--express的使用
        1、 引入express
                const express = require('express');
        2、创建应用对象
                const app = express();
        3、创建路由规则
            request是对请求报文的封装、response是对响应报文的封装
            这里的请求为get请求
                app.all('/serve',(request,response) => { //用于设置响应，如果最后返回的路径中含有/serve的话，那么就执行下面的响应
                    response.setHeader('Access-Control-Allow-Origin','*') //设置响应头，设置允许跨域
                    response.setHeader('Access-Control-Allow-Headers', '*');//设置响应头，设置允许自定义响应头，同时上面的app.get需要改为app.all
                    const data = {//响应一个JSON对象数据
                        name: 'at'
                    };
                    let str = JSON.stringify(data);//send()方法中只能返回字符串，所以对于上面的JSON数据，我们需要进行字符串转换
                    response.send(str);//转换之后设置响应体
                })
        4、监听端口启动服务
                app.listen(8000,() => {
                    console.log("服务已经启动，8000端口监听中...");
                });
            在控制台启动服务器：node serve.js
            最终测试，在浏览器地址栏中输入 127.0.0.1:8000  
        5、加入前端代码测试
            ()前端代码一般新建文件夹static中
            ()在服务器的代码中：app.use(express.static(__dirname+'/static'))
            ()以上都做好之后，就可以在开发中把前端人员交给后端的代码（dist文件夹中的所有东西）放到static文件夹中
            ()部署完之后，重新执行node serve
            ()如果前端配置路由时使用的是hash模式，那么路由跳转之后再刷新，界面不会出不来，假设使用了history模式，那么久需要后端
              工程师通过 connect-history-api-fallback去解决-->




    <!--ajax的get请求的使用方法-------这种方法在开发中不常用
        (1) 在使用前注意端口是否开放，比如这里的8000端口需要重新启动“node case.js”，上面所以代码整合在一起就可以进行数据交  互，其他的语法就是所学的语法了
            例如写好了js上述代码的文件，在html文件中
                const btn = document.getElementById('btnGET');
                btn.onclick = function() {
                    //发送请求的代码，步骤不管是发送请求还是接受请求都是一样的
                    const xhr = new XMLHttpRequest();              1、创建对象
                    xhr.open('GET','http://127.0.0.1:8000/serve')  2、初始化，设置请求方法（get、post）和给谁发送 url
                    xhr.send()                                     3、发送请求
                    xhr.onreadystatechange = function(){         4、事件绑定，处理服务器返回的结果

                        //判断服务端是否返回了所有的结果
                        /*readyState  是xhr对象中的属性 有四个值：0（未初始化，其最开始的值）、1（open方法已经调用完毕）、 2(请求已经发送——send()方法完成,已经收到全部响应 内容)、3（ 服务器返回了数据（但是还没有被解析，可能只一段http报文））、 4（服务端返回了所有的结果）*/

                        if(xhr.readyState === 4){
                        if(xhr.status >= 200 && xhr.status <300){  //判断响应状态码  200 404 403 401 500 ，只要状态码为2xx 就表示成功
                            //处理结果  行 头 空行（目前在这里没有实际意义） 体
                            console.log('状态码', xhr.status); 
                            console.log('状态字符串', xhr.statusText);
                            console.log('所有响应头', xhr.getAllResponseHeaders()); 
                            console.log('响应体', xhr.response);

                            result.innerHTML = xhr.response;  //设置 result 的文本，结果返回为“Hello Ajax”，是case.js文件中的响应内容
                        } else {}
                        }
                            }
                        } 
                    
        (2) 如何在Ajax中给url地址传递参数（get请求）
            (1) 每一个参数以 “&” 作为分隔符，参数部分与前面地址之间用 “？” 作为分隔符
            (2) 参数的书写在 xhr.open('GET','http://127.0.0.1:8000/serve') 中
                例如： xhr.open('GET','http://127.0.0.1:8000/serve？a=100&b=100')
            (3) 响应的参数可以在浏览器  检查-NetWork-All-PlayLoad  中查看-->




    <!--Ajax的post（）请求
        (1) 例如：当鼠标放到盒子上的时候，向服务器发送post请求，服务器返回请求结果，在盒子中呈现出来
            当前只有一个盒子样式
                    const result = document.getElementById('result');
                    result.addEventListener("mouseover", function() {
                        //开始发送请求
                        const xhr = new XMLHttpRequest();
                        xhr.open('POST', 'http://127.0.0.1:8000/serve')
                        xhr.send()
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState === 4) {
                                if (xhr.status >= 200 && xhr.status < 300) {
                                    result.innerHTML = xhr.response;
                                }
                            }
                        }
                    });
            
        (2) post请求如何设置参数
                (1) 请求体在 send() 方法种设置
                (2) 设置格式与url传递参数一致，也是以 “&” 间隔两个参数  
                        send('a=100&b=200')   或者   send('a:100&b:200')
                    post请求成功的参数查看方法与get一样 -->




    <!--设置请求报文的请求头
        (1) 使用设置请求头的方法 setRequestHeader()  设置的位置为 open() 方法之后
                xhr.open('POST', 'http://127.0.0.1:8000/serve');
                xhr.setRequestHeader('','');
        (2) setRequestHeader('','')
                第一个参数是“头的名字” 第二个参数是”头的值“
                xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
                每设置一个请求头的参数都要用一次上面的写法
                如果想要设置自定义的请求头的话，可以进行如下操作，不然会报错：
                    在设置请求post函数中（例如postAndget.js中的post请求部分）添加一句代码：
                        response.setHeader('Access-Control-Allow-Headers','*');
                    再将“post”改为“all”-->




    <!--JSon 
        (1) 在实际请求过程中，我们向服务器发送请求时，服务端返回的结果基本上都是JSon格式的数据，我们需要对这json数据进行处理
        (2) 1、首先在请求中响应一个json数据
                const data = {
                    name: 'atuhusi'
                };
                由于send方法中只能响应字符串，所以需要将数据对象转化为字符串：
                let str = JSON.stringify(data);       再将str丢入send方法中
            2、在浏览器这边，需要解析JSON数据
                (1)方法一：手动进行数据转化
                        let data = JSON.parse(xhr.response);
                        result.innerHTML = data.name;      这里想要获取JSON数据中的name属性值，data是json数据名
                (2)方法二：创建XMLHTTPResponse对象时，设置xhr的响应类型
                        const xhr = new XMLHttpRequest();
                        xhr.responseType = 'json';
                        result.innerHTML = xhr.response.name;   这行代码是在绑定事件中同样获取name属性值-->



    <!--nodemon工具
        (1) 用途：能够帮我们重启服务，可以自动检测node.js中的代码变化，一旦变化了，能够自动帮我们重启服务，就不需要我们重新手动重启了.
                注意：下面的postAndget.js 是我们想要启动请求的一个文件
        (2) 安装需要基于nodejs和npm 在终端中输入如下指令：
            PS D:\study\WebCode\ajax> npm install -g nodemon
        (3) 安装完之后，我们需要重新启动一下我们的 postAndget.js ，启动的代码如下：
            nodemon postAndget.js
            如果遇到报错“系统上禁止运行脚本”，在前面加上npx：
            npx nodemon postAndget.js
        (4) 上面步骤完毕之后，我们修改了代码文件只需要保存就行了，无需重启-->





    <!--请求超时与网络问题处理
        (1)当浏览器向服务器请求时，超过了一定的时间还没有把请求的数据拿到，这个时候我们可以添加一个请求延时响应
        (2) 在请求文件中增加一个定时器：
                setTimeout(() => {
                    response.send('延时响应');
                }, 3000)
            在浏览器js文件中添加如下代码：
                xhr.timeout = 2000;    //超时设置2s，2s之后会请求失败
                xhr.ontimeout = function(){
                    alert('网络异常，请稍后重试！！');     //超时后结果，一般在实际开发中不会那么生硬地弹窗
                }
        (3) 网络问题也可以像上面那样处理，增加这段代码：
                xhr.onerror = function() {
                    alert('你的网络似乎出现了一些问题。。。')
                }-->




    <!-- 取消请求
        (1) 在请求的过程中，当响应体未返回来的时候，中断请求
        (2) 取消请求使用到一个方法 abort()
            btns[1].onclick = function() {
                x.abort();
            }                    
            注意这部分代码与请求的函数不是在一个函数中，同时我们需要把创建的实例对象x定义在外面：
            const btns = document.querySelectorAll('button');
            let x = null;
            同时创建对象不需要const，否则会报错，因为这是一个块级作用域
            x = new XMLHttpRequest();-->



    <!--请求重复发送问题
        (1) 当重复的请求太多时，会增加服务器的压力，所以当我们发起一个请求的时候，如果前面发送过一样的，那就先取消之前发送的请求，再发送当前请求。使用  “节流阀” 解决该问题
        (2) 添加一个标识变量 isSending ，当发送请求时改为true
            let isSending = false;
            let xhr = null;
            btn.onclick = function(){
                if(isSending) xhr.abort();      //如果正在发送该请求，则取消请求，再次发送
                const xhr = new XMLHttpRequest();
                isSending = true;
                xhr.open('GET','http://127.0.0.1:8000/serve');
                xhr.send();
                xhr.onreadyStatechange = function(){
                    if(xhr.readyState === 4){       //不需要判断请求是否成功，不管成不成都需要中断请求
                        isSending = false;          //这个时候再修改标识变量，
                    }
                }
            }-->





    <!--axios 发送请求------主流技术栈
        (1) 也是进行发送请求的一种方式
        (2) 直接下载，打开控制台： npm i axios
        (3) 接着在App.vue组件中引入： import axios form 'axios'
        (3) 使用，与jQuery相似：
                btn.onclick = function(){
                    axios.get('http://127.0.0.1:8000/serve'（需要的数据所在的那个地址）,{
                        username:'admin',      //请求数据，json格式
                        password:'admin'
                    },{ //设置其他参数
                        params: {      //设置url参数
                            id:100,
                            vip:7
                        },
                        headers:{        //请求头
                            name:'guiGu',
                            age:20
                        }
                    })
                }
        (4) 使用通用方法发送请求
                btn.onclick = function(){
                    axios({
                        method:'POST',   //请求方法，不写method配置，就默认是GET请求
                        url:'http:127.0.0.1:8000/serve',   //url地址，是一定要写的
                        params:{      //是与请求一起发送的 URL 参数
                            vip:10,
                            level:30
                        },
                        headers:{     //请求头信息
                            a:100,
                            b:200
                        },
                        data:{       //作为请求体被发送的数据
                            username:'admin',
                            password:'admin'
                        },
                        timeout:10000    //超过这个时间，请求会被中断
                    }).then(response => {    //对响应结果进行处理
                            console.log(response);
                    })
                }
        (5)在vue组件中
                写在某个方法里，在APP主组件中：
                getStudents() {
                    axios.get("http://localhost:5000/students").then(
                        response=>{    //请求成功了之后对数据进行操作
                            console.log('请求成功了',response.data)    响应对象response中的data属性就是请求获取到的数据data
                        },
                        error => {     //请求失败了之后怎么做
                            console.log('请求失败了',error.message)     error是请求失败对象，其中的message属性才是失败信息
                        }
                    )},
        (6)拦截器
            ()请求拦截器
                axios（axios的实例）.interceptors.request.use(function (config) {
                    // 在发送请求之前做些什么
                    return config;
                }, function (error) {
                    // 对请求错误做些什么
                    return Promise.reject(error);
                });
            ()添加响应拦截器
                axios.interceptors.response.use(function (response) {
                    // 2xx 范围内的状态码都会触发该函数。
                    // 对响应数据做点什么
                    return response;
                }, function (error) {
                    // 超出 2xx 范围的状态码都会触发该函数。
                    // 对响应错误做点什么
                    return Promise.reject(error);
                });-->





    <!--Jquery中的Ajax----是XML的封装
        1、浏览器中的XMLHttpRequest用法比较复杂，所以JQuery对其进行了封装，提供了一系列Ajax相关的函数，极大地降低了Ajax的使用难度
        2、jQuery中发起Ajax请求最常用的是哪个方法如下：

            (1) $.get(请求的url地址,[data],[callback],[type])  后面两个参数不是必须写的
                       data   q请求期间要求携带的参数
                       callback  请求成功之后的回调函数
                       type   返回内容格式
                例如：
                       $.get('http://www.liulongbin.top:3006/api/getbooks',{a=100,b=200},function(res){
                            console.log(res);     //这里的res是服务器返回的数据
                       })
            (2) $.post()一样的   -->


    <!-- 跨域
        1、同源策略
            (1) 同源策略（Same-Origin Policy）最早有NetScape公司提出，是浏览器的一种安全策略。
            (2) 同源：要求我们当前网页的url和Ajax目标请求的url必须 协议、域名、端口号 完全相同。
            (3) 跨域：违背同源策略
        2、解决跨域
            (1) JSONP
                    JSONP是一个非官方的跨域解决方法，纯粹凭借程序员的聪明才智开发出来的，只支持get请求
                    JSONP工作原理：有一些网页标签天生具有跨域n能力，比如：img、link、iframe、script，JSONP就是利用script的跨域能力来发送请求的
            (2) CORS
                    CORS是跨域资源共享，是官方的跨域解决方案，不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持POST、GET请求，跨域资源
                    共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权访问哪些资源。
                工作原理：通过设置一个响应头来告诉浏览器，该请求允许跨域
                使用方法：在服务器端添加如下代码：
                        response.setHeader('Access-Control-Allow-Origin', '*');
            (3)配置代理服务器
                ）代理服务器位于本机与请求地址之间，其端口号与本机相同（例如都是8080）
                ）本机先向代理服务器发送请求，此时不需要跨域；代理服务器再向请求地址发送请求，因为请求地址也是个服务器，服务器之间
                  不存在跨域问题，都是用的http协议
                ）开启代理服务器-----使用vue-cli
                    方式一：
                    ()找到vue.config.js，增加下面这句代码
                        module.exports = {
                            ....,//其他代码
                            //开启代理服务器
                            devServer:{
                                proxy:'http://localhost:5000'    //这里的5000端口就是你需要跨域请求的服务器的端口号，只需要写到端口号
                            }
                        }
                        注意：
                            因为修改了脚手架的配置，记得停掉之后重新node运行
                    ()回到axios请求中，将请求地址由需要跨域解决的5000改为本机端口号8080
                    ()缺点：如果在本机中有和请求同样的文件名的时候，请求就会直接在本机拿了，而不会去5000端口
                           不能配置多个代理，不能控制是否要走代理
                    ()应用：使用这个代理配置方式，当想要的数据前端不存在时，就去请求服务器
                    知识点：
                        在vue组件中，8080端口持有的数据都放在了public文件夹中，想要这个数据就直接输入地址，例如：http://localhost:8080/favicon.ico
                    
                    方式二：
                    ()也是找到与方式一相同的文件，修改代码：
                         module.exports = {
                            ....,//其他代码
                            //开启代理服务器
                            devServer:{
                                proxy:{
                                    '/api':{                                //  /api为请求前缀，在axios请求中的地址中前缀书写的位置为端口号后面，想要代理服务器进行请求时，需要表明请求前缀是什么，
                                        target:'http://localhost:5000',         然后来这里找对应的，
                                        pathRewrite:{'^/api':''}           //因为想要请求的服务器中并没有/api，而当没有这句代码的时候，代理服务器是将/api作为地址的一部分发送出去的，所以必须清空前缀
                                        ws:true,                            //用于支持websocket
                                        changeOrigin:true                  //将代理服务器的端口号改成与拥有数据的服务器相同，也就是控制服务器收到的请求的请求头中的Host值
                                    },
                                    '/foo':{
                                        target:'<other_url>'
                                    }
                                }
                            }-->
</body>

</html>