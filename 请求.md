### 客户端与服务器

**服务器**：上网过程中，负责存放和对外提供资源的电脑

**URL**：UniformResourceLocator，中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置

-  组成部分

    http （服务器与客户端之间的通信协议）://www.cnblogs.com（存有该资源的服务器名称）/ liulongbinblogs/p/11649393.html（资源在服务器上的具体存放位置）

**资源请求方式**

​      客户端请求服务器时，请求方式有多种，最常用的两种请求方式就是 **get** 和 **post** 请求	

- HTTP 1.0 定义了3种请求方法： get、post 和、head方法。
  ​HTTP 1.1 新增了5种请求方法：options, put, delete, trace 和 connect方法

  - **get**：客户端向服务器获取数据信息，不做任何修改操作

  - **head**：与get方法相同，但没有响应体，仅传输状态行和标题部分，通常用来获取资源信息，这些信息蕴含在响应头中，比如[Content-Length](https://so.csdn.net/so/search?q=Content-Length&spm=1001.2101.3001.7020), 客户端只是想知道自己将要请求的资源有多大，而并不是真的想要获取这份资源，那么就可以使用head方法进行查看。

  - **post**：客户端将数据发送给服务器以创建或更新资源，着重于update，提交的数据一般有两种格式：form表单、json数据

  - **put**：客户端将数据发送给服务器以创建或更新资源，着重于创建insert

  - **patch**：和put一样，也用于资源的更新，PATCH用于资源的部分更新，PUT多用于资源的整体更新
    如果资源不存在，使用PATCH时应创建一个新的资源，而PUT则不要求创建新资源

  - **delete**：删除URI给出的目标资源的所有当前内容

  - **options（**预检请求）：可以测试服务器功能是否正常，服务器会返回这个资源所支持的HTTP请求方法，在javascript中，使用XMLHttpRequest对象进行CORS跨域资源共享时，会先使用options方法进行嗅探，以此判断对指定资源是否具有访问权限。

    **携带的请求头信息：**Access-Control-Request-Method：告诉服务器实际请求所使用的 HTTP 方法；

    ​								   Access-Control-Request-Headers：告诉服务器实际请求所携带的自定义首部字段；

    ​								  Origin：发起请求的域名 （协议、域名、端口号）

    **响应头信息：**Access-Control-Allow-Methods：服务端允许的请求，包含 get、head之类的

    ​						Access-Control-Allow-Credentials：允许跨域携带 cookie

    ​						Access-Control-Allow-Origin：允许跨域请求的域名

    ​						Access-Control-Allow-Headers：客户端请求所携带的自定义首部字段

  - **connect**：一般工作中不会遇到，它的作用是让服务器作为代理，让服务器代替用户访问其他网页，其实就是代理服务器。

  - **trace**：用于http请求的测试和诊断，根据协议，服务器在收到trace请求后，应回显所收到的数据，即服务器返回自己所收到的数据。



### XMLHttpRequest（简称xhr）

浏览器提供的js成员，通过它，可以请求服务器上的数据资源，类似Dom对象



### Ajax

- **含义**

​      全称是Asynchronous JavaScript And XML （异步JavaScript和XML）

​      就是在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式，就是Ajax

​      最大的特点：无刷新获取数据

- **XML**

​      XML被设计用来传输和存储数据，XML和HTML类似，不同的是HTML中都是预定义标签，而XML全都是自动以标签，用来表示一些数据。

​      比如有一个学生数据：  name = "sun"; age = 18; sex = "男"

​      用XML表示：<student>

​             					 <name> sun </name>

​              					<age>18</age>

​              					<sex>男</sex>

​            				</student>

​      用JSON表示：{"name":"sun","age":18,"sex":"男"}   目前都是使用的JSON

-  **优缺点**
  -  优点： 可以无需刷新页面而与服务器端进行通信；允许你根据用户事件更新部分页面
  -  缺点： 没有浏览历史，不能回退；存在跨域问题（同源）； SEO不友好

- **发送请求**

  ```js
  const btn = document.getElementById('btnGET');
  btn.onclick = function() {
  	//发送请求的代码，步骤不管是发送请求还是接受请求都是一样的
     	const xhr = new XMLHttpRequest();  						  //1、创建对象
  	xhr.open('GET','http://127.0.0.1:8000/serve?a=100&b=100') //2、初始化，get请求参数
      xhr.setRequestHeader('Content-Type','value');  //设置请求头信息
      //3、发送请求，携带参数:send('a=100&b=200')或者send('a:100&b:200') ,get请求则置空
  	xhr.send() 
  	xhr.onreadystatechange = function(){          //4、事件绑定，处理服务器返回的结果       
          if(xhr.readyState === 4){
  			if(xhr.status >= 200 && xhr.status <300){  //只要状态码为2xx 就表示成功
              	//处理结果  行 头 空行（目前在这里没有实际意义） 体
                  console.log('状态码', xhr.status); 
                  console.log('状态字符串', xhr.statusText);
                  console.log('所有响应头', xhr.getAllResponseHeaders()); 
                  result.innerHTML = xhr.response;  //处理响应内容
              } else {}
          }
  	}
      xhr.timeout = 2000;        //超时设置2s，2s之后会请求失败
      xhr.ontimeout = function(){
         //超时后的处理
      }
      xhr.onerror = function() {
         //请求失败后的处理
      }
  }
  /*readyState  是xhr对象中的属性，有四个值：
  	0（未初始化，其最开始的值）
  	1（open方法已经调用完毕）
  	2(请求已经发送——send()方法完成,已经收到全部响应内容)
  	3（服务器返回了数据，但是还没有被解析，可能只一段http报文）
  	4（服务端返回了所有的结果）*/                    
  ```

- **取消请求**

  xxx.abort()





### axios  -- 主流技术栈

配置axios请求发送环境

```js
//安装插件
npm i axios
//接着在App.vue组件中引入
import axios form 'axios'
```

- **发送请求**

```js
btn.onclick = function(){
	axios.get('http://127.0.0.1:8000/serve',{
		username:'admin',    //请求携带的数据
		password:'admin'
		},{ //设置其他参数
            params: {      //设置请求参数
              id:100,
              vip:7
            },
            headers:{        //请求头
               name:'guiGu',
               age:20
        }
    })
}
//第二种请求语法
btn.onclick = function(){
   axios({
      method:'POST',   //请求方法，不写method配置，就默认是GET请求
      url:'http:127.0.0.1:8000/serve',   //url地址，是一定要写的
      params:{      //请求参数
          vip:10,
          level:30
      },
      headers:{     //请求头信息
          a:100,
          b:200
      },
      data:{       //作为请求体被发送的数据
          username:'admin',
          password:'admin'
      },
      timeout:10000    //超过这个时间，请求会被中断
   }).then(response => {    //请求成功，对返回体进行处理
      console.log(response);
   })
}
```

- **拦截器**

```js
//请求拦截器
axios.interceptors.request.use(function (config) {
     // 在发送请求之前做些什么
     return config;
}, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
});
//响应拦截器
axios.interceptors.response.use(function (response) {
   // 2xx 范围内的状态码都会触发该函数。
   // 对响应数据做点什么
   return response;
}, function (error) {
   // 超出 2xx 范围的状态码都会触发该函数。
   // 对响应错误做点什么
   return Promise.reject(error);
});
```



#### 请求封装

企业项目中请求的封装步骤：

1、下载axios

```js
npm i axios
```

2、在src下新建文件夹 **apis**，在文件夹apis下新建 **request.ts **文件

```js
//request.ts
import axios from 'axios';
import type { AxiosRequestConfig, AxiosInstance, InternalAxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';

const COMMON_REQUEST_METHOD = 'POST'; //缺省请求方法
const DEFAULT_TIMEOUT = 120000; //缺省请求超时时间 2min

//请求配置对象
const config: AxiosRequestConfig = {
    // 设置超时时间
    timeout: DEFAULT_TIMEOUT,
    // 缺省请求方法
    method: COMMON_REQUEST_METHOD,
    // 跨域时候允许携带凭证
    withCredentials: true
};

export class CustomAxiosInstance {
    //axios实例变量
    instance: AxiosInstance;

    constructor(axiosConfig: AxiosRequestConfig) {
        this.instance = axios.create(axiosConfig);
        this.setupInterceptor();
    }

    //设置请求拦截器和响应拦截器
    setupInterceptor () {
        //请求拦截器，在请求发送之前，对请求头进行处理，比如添加特定的请求头或者对请求的数据格式进行转化
        //在请求发送前对请求进行处理，use 方法接受两个函数作为参数，第一个函数用于处理请求成功，第二个函数用于处理请求失败
        this.instance.interceptors.request.use(
            async (config: InternalAxiosRequestConfig) => {
                // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了
                // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断
                const token = localStorage.getItem('Token')
                //检查是否成功获取到 token，如果存在，则将它添加到请求的 headers 中的 Authorization 字段。这是一种在每个请求中添加 token 的方式，用于身份验证。
 				//设置增加请求头Authorization，value为token
                if( token !== null ) {
                    config.headers.Authorization = token;
                }
                if(config.method.toUpperCase() === 'POST') {
                    config.headers['Content-Type'] = 'application/json;charset=utf-8'
                }
                return config
            }
        );

        //响应拦截器
        this.instance.interceptors.response.use(
            //use同样接受两个函数，第一个处理成功，第二个处理失败
            //AxiosResponse中包含了响应信息，包括状态码，数据等
            async (response: AxiosResponse) => {
                //从响应信息中解构出状态码status、响应数据data
                const { status, data } = response;
                //从响应数据中解构出业务状态码code
                const { isSuccess } = data;

                if ((status === 200 || status < 300 || status === 304) && isSuccess === true) {
                    // 真正的请求成功，只有业务状态码code和请求状态码status都符合预期,isSuccess是人为设置的
                    return Promise.resolve(data);
                } else {
                    //请求成功，但是不是预期的状态，所以设定请求为失败
                    return Promise.reject(data);
                }
            },
            //AxiosError中包含了响应错误的详细信息，如错误码、错误信息等
            (error: AxiosError) => {
                //请求失败，返回错误信息
                if (error.code === 'ERR_CANCELED') {
                    return Promise.reject('ERR_CANCELED');
                }

                if (error.code === 'ERR_NETWORK') {
                    console.log('网络异常, 请检查网络');
                }
                console.log('response interceptor error', error);
                //请求发送失败，请求没法送到数据库中
                return Promise.reject(error);
            }
        );
    }

    /** 常用请求方法封装 */
    get(url: string, params: any = null, config: AxiosRequestConfig = {}) {
        return this.instance.get(url, { params, ...config });
    }
    
    post(url: string, data: any, config: AxiosRequestConfig = {}) {
        return this.instance.post(url, data, { ...config });
    }
}

export default new CustomAxiosInstance(config);
```

3、在 **vite.config.ts** 文件下进行代理

```js
export default defineConfig(() => {
  return {
    //start：代理
    server: {
      port: 8989,
      open: true,
      proxy: {
          //正则表达式，所有以/collect|/sysDialog|/user开头的请求地址都使用target的域名，如果还有其他域名，则在下面以一样的格式补充
          '^(/collect|/sysDialog|/user)': {
              target: 'http://10.38.170.192:8081/',    //请求域名
              changeOrigin: true,
          }
      }
  	},
     //end:代理
    resolve: {
      alias: {
        '@': '/src'
      }
    },
    plugins: [
      vue(),
    ],
  }
})
```

4、在文件夹apis下新建modules文件夹，在该文件夹中可新建每一类作用请求的文件

```js
//  /modules/create.ts
import request from './request.ts';

/**
 * 用户登录
 */
export function fetchLoginIn(params: any) {
    return request.post('/user/login', params);
}

/**
 * 获取模板信息
 */
export function fetchTempEditForm(id: number) {
    return request.get(`/xe.ai.copywriting/hub/template?id=${id}`);
}
```

5、使用常规的方法进行请求发送



### express

**概念**

​		express的作用和Node.js内置的http模块类似，是专门用来创建Web服务器的，express是基于http模块进一步封装出来的，相比于http方法更全面、更简洁，是一个npm上的第三方包。

**使用流程**

```js
//下载包
npm i express

//创建基本的Web服务器
const express = require('express')        //1.导入express包
const app = express()                     //2、创建Web服务器
app.listen(8000,() => {            //3、调用 app.listen(端口号，启动成功后的回调函数)，启动服务器
    console.log('8000端口服务器启动中....')
})
```



